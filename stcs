if not game:IsLoaded() then game.Loaded:Wait() end

-- main bypasses ----------
local MT = getrawmetatable(game)

local OldIndex = MT. __index
local OldNamecall = MT.__namecall

setreadonly(MT, false)

MT.__index = newcclosure(function(P, M, TH, TI, HB, SZ)
	if not checkcaller() and getnamecallmethod() then
		if tostring(P) == "Position" and tostring(M) == "Magnitude" then return end
		if tostring(HB) == "HumanoidRootPart" and tostring(SZ) == "Size" then return end
		if tostring(TH) == "Handle" then return end
		if tostring(TI) == "firetouchinterest" then return end
	end
	return OldIndex(P, M, TH, TI, HB, SZ)
end)

for _, v in next, getconnections(game:GetService("LogService").MessageOut) do v:Disable() end
for _, v in next, getconnections(game:GetService("ScriptContext").Error) do v:Disable() end
game:GetService("ScriptContext"):SetTimeout(0.1)

setreadonly(MT, true)
------------------------------------


getgenv().set = {
	aim = {
		toggle = true,
		radius = 10
	},
	
	jump = {
		toggle = true,
		radius = 10
	},

	amp = {
		toggle = true,
		damage = 1
	}
}

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

local lastDamageTick = 0
local DamageTickCooldown = 0.1

local LastJumpTime = 0
local JumpCooldown = 0.6

local zone = workspace.Terrain.Spawn:FindFirstChild("SafePlate")
if not zone then return end

local ZonePos = zone.Position
local ZoneSize = zone.Size
local area = Vector3.new(ZoneSize.X, 0, ZoneSize.Z) / 2

local XZ = {
	minX = ZonePos.X - area.X,
	maxX = ZonePos.X + area.X,
	minZ = ZonePos.Z - area.Z,
	maxZ = ZonePos.Z + area.Z
}

local wiggle = function()
	if not set.aim.toggle then return end

	local character = player.Character
	local rootpart = character and character:FindFirstChild("HumanoidRootPart")
	local humanoid = character and character:FindFirstChild("Humanoid")

	if not character or not rootpart or not humanoid then return end

	local position = rootpart.Position
	if position.X >= XZ.minX and position.X <= XZ.maxX and position.Z >= XZ.minZ and position.Z <= XZ.maxZ then return end

	for _, Player in pairs(Players:GetPlayers()) do
		if Player.Name ~= player.Name then

			local otherchar = Player.Character
			local otherroot = otherchar and otherchar:FindFirstChild("HumanoidRootPart")
			local otherhum = otherchar and otherchar:FindFirstChild("Humanoid")

			if not otherchar or not otherroot or not otherhum then continue end

			local pos = otherroot.Position
			if pos.X >= XZ.minX and pos.X <= XZ.maxX and pos.Z >= XZ.minZ and pos.Z <= XZ.maxZ then continue end

			if otherhum.Health <= 0 then continue end
			if humanoid.Health <= 0 then return end

			if otherroot then
				local distance = (otherroot.Position - rootpart.Position).Magnitude

				if distance <= 5 then
					task.spawn(function()
						local angle = math.sin(1 * 1) * 1
						camera.CFrame = camera.CFrame * CFrame.Angles(0, angle, 0)
						task.wait(0.01)
						camera.CFrame = camera.CFrame * CFrame.Angles(0, -angle, 0)
					end)
				end
			end
		end
	end
end

local UpdateCamAim = function()
	if not set.aim.toggle then return end

	local character = player.Character
	local rootpart = character and character:FindFirstChild("HumanoidRootPart")
	local humanoid = character and character:FindFirstChild("Humanoid")

	if not character or not rootpart or not humanoid then return end

	local position = rootpart.Position
	if position.X >= XZ.minX and position.X <= XZ.maxX and position.Z >= XZ.minZ and position.Z <= XZ.maxZ then return end

	for _, Player in pairs(Players:GetPlayers()) do
		if Player.Name ~= player.Name then

			local otherchar = Player.Character
			local otherroot = otherchar and otherchar:FindFirstChild("HumanoidRootPart")
			local otherhum = otherchar and otherchar:FindFirstChild("Humanoid")

			if not otherchar or not otherroot or not otherhum then continue end

			local pos = otherroot.Position
			if pos.X >= XZ.minX and pos.X <= XZ.maxX and pos.Z >= XZ.minZ and pos.Z <= XZ.maxZ then continue end

			if otherhum.Health <= 0 then continue end
			if humanoid.Health <= 0 then return end

			if otherroot then
				local distance = (otherroot.Position - rootpart.Position).Magnitude

				if distance <= set.aim.radius then
					local RightArm = otherchar and otherchar:FindFirstChild("Right Arm")
					if not RightArm then continue end

					local direction = Vector3.new(RightArm.Position.X - otherroot.Position.X, 0, RightArm.Position.Z - otherroot.Position.Z).Unit
					local lookat = Vector3.new(otherroot.Position.X, camera.CFrame.LookVector.Y, otherroot.Position.Z) + direction
					local NewCFrame = CFrame.new(camera.CFrame.Position, lookat)
					
					camera.CFrame = NewCFrame
					
				elseif distance <= 3 then
					task.spawn(function()
						local angle = math.sin(1 * 1) * 1
						camera.CFrame = camera.CFrame * CFrame.Angles(0, angle, 0)
						task.wait(0.01)
						camera.CFrame = camera.CFrame * CFrame.Angles(0, -angle, 0)
					end)
				end
			end
		end
	end
end

local jump = function()
	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") or not character:FindFirstChild("Humanoid") then return end

	local CurrentTime = tick()
	if CurrentTime - LastJumpTime < JumpCooldown then return end

	local ClosestDistance = set.jump.radius

	for _, Player in ipairs(Players:GetPlayers()) do
		if Player ~= player and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") and Player.Character:FindFirstChild("Humanoid").Jump then
			local Distance = (character.HumanoidRootPart.Position - Player.Character.HumanoidRootPart.Position).Magnitude
			if Distance < ClosestDistance then
				character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
				LastJumpTime = CurrentTime
				break
			end
		end
	end
end

local amp = function()
	if not set.amp.toggle then return end
	
	local Char = player.Character
	local Rootpart = Char and Char:FindFirstChild("HumanoidRootPart")
	local Humanoid = Char and Char:FindFirstChildOfClass("Humanoid")
	
	if not Char or not Rootpart or not Humanoid then return end
	
	local position = Rootpart.Position
	if position.X >= XZ.minX and position.X <= XZ.maxX and position.Z >= XZ.minZ and position.Z <= XZ.maxZ then return end
	
	for _, others in pairs(Players:GetPlayers()) do
		if others.Name ~= player.Name then

			local othersChar = others.Character
			local othersRootpart = othersChar and othersChar:FindFirstChild("HumanoidRootPart")
			local othersHumanoid = othersChar and othersChar:FindFirstChildOfClass("Humanoid")
			
			if not othersChar or not othersRootpart or not othersHumanoid then continue end
			
			local pos = othersRootpart.Position
			if pos.X >= XZ.minX and pos.X <= XZ.maxX and pos.Z >= XZ.minZ and pos.Z <= XZ.maxZ then continue end
			
			if othersHumanoid.Health <= 0 then continue end
			if Humanoid.Health <= 0 then return end
			
			local tool = Char and Char:FindFirstChildOfClass("Tool")
			local Handle = tool and tool:FindFirstChild("Handle")
			if not tool and Handle then return end 

			pcall(function()
				for _, hit in pairs(Handle:GetTouchingParts()) do
					if hit:IsA("BasePart") then
						
						local TargetChar = hit.Parent
						if TargetChar == Char then return end 
						
						local CurrentTime = tick()
						if CurrentTime - lastDamageTick < DamageTickCooldown then return end	-- < Damage ticking cooldown

						for _ = 1, set.amp.damage do -- < ticks per cooldown
							firetouchinterest(hit, Handle, 0)
							firetouchinterest(hit, Handle, 1)
						end
					end
				end
			end)
		end
	end
end

RunService.Heartbeat:Connect(function()
	amp() jump()
end)
RunService.Stepped:Connect(function()
	UpdateCamAim() wiggle()
end)
